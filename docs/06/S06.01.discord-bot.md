- [Discord bot](#discord-bot)
  - [Les étapes de creation du bot](#les-étapes-de-creation-du-bot)
    - [1) Local](#1-local)
    - [2) Déployer sur une VM](#2-déployer-sur-une-vm)
    - [3) Ajouter le linting](#3-ajouter-le-linting)
  - [Demo du bot](#demo-du-bot)
- [Le bot](#le-bot)
  - [Créer votre bot sur le portail Discord](#créer-votre-bot-sur-le-portail-discord)
    - [le DISCORD\_TOKEN](#le-discord_token)
    - [L'environnement local](#lenvironnement-local)
    - [Le bot dans main.py](#le-bot-dans-mainpy)
    - [A vous](#a-vous)
      - [Le Dockerfile](#le-dockerfile)
      - [Le compose.yaml](#le-composeyaml)
    - [Inviter le bot sur le server discord](#inviter-le-bot-sur-le-server-discord)
    - [ajouter des fonctinonalités](#ajouter-des-fonctinonalités)
    - [Other services that could be useful for a more complex bot](#other-services-that-could-be-useful-for-a-more-complex-bot)
    - [Multi stage builds](#multi-stage-builds)
  - [GitHub Actions Setup](#github-actions-setup)
  - [validate, lint, test Dockerfile and compose.yaml](#validate-lint-test-dockerfile-and-composeyaml)
    - [Then deploy to host](#then-deploy-to-host)
  - [Running Locally with Docker](#running-locally-with-docker)



# Discord bot

Le plan de l'après midi: construire un bot Discord

D'abord en local, puis dans le cloud

ce qui nous permettra d'illustrer et de pratiquer les points suivant

- multi stage build dans Dockerfile : from alpine install python ...
- Gestion des *secrets* avec Github secrets
- Déploiement  with github actions (CI/CD)
- Lint : comment améliorer la qualité de son code, appliqué aux dockerfiles compose.yaml et python
- plusieurs stratégies pour déployer une image docker (avec ou sans docker hub).



## Les étapes de creation du bot

### 1) Local

1. créer une application dans Discord Developer Portal, ouvrir un compte, remplir des pages web. facile
2. prendre le script python dans la repo github : `main.py`
3. écrire un `Dockerfile`
4. écrire un `compose.yaml` pour docker compose

Lancer le bot avec `docker compose up -d`

Jouer avec le bot!

### 2) Déployer sur une VM

- créer une repo github avec le code python du bot et un `readme.md`
- prendre le fichier `deploy.yml` sur le github
  - comprendre `deploy.yml`: deploy, ssh keys
  - ajouter les secrets dans github
- push to master => et voir le déploiement

Jouer avec le bot!

### 3) Ajouter le linting

Le linting ?

Ajouter des étapes de Linting et de validation des fichiers dockerfile, compose.yaml et python


## Demo du bot

quelques commandes

- /hello
- /ping
- /inspire
- /roll 2d6


# Le bot

Sur votre local créez un nouveau repertoire

```bash
mkdir discord-bot
cd discord_bot
```


## Créer votre bot sur le portail Discord

1. Go to the Discord Developer Portal : <https://discord.com/developers/applications>
2. Click "New Application" and give it a name
3. Go to the "Bot" tab and click "Add Bot"
4. Under the bot's username, click "Copy" to copy your bot's token `DISCORD_TOKEN`


### le DISCORD_TOKEN

Il faut garder le `DISCORD_TOKEN` secret!

Pour cela dans le repertoire `discord-bot`, creez une fichier `.env` et ajoutez la ligne

```text
DISCORD_TOKEN=<le token>
```

Gérer le token pour qu'il reste secret et que le fichier `.env` ne soit pas copié dans le container va être un fil rouge du projet.


### L'environnement local

Nous n'avons pas besoin d'installer python puisque nous avons docker!

Mais nous avons quand meme besoin du script python du bot : `main.py`

récupérez le depuis https://github.com/SkatAI/ynov-docker/blob/master/apps/discord-bot/src/main.py

Par convention on met les fichiers python dans un sous repertoire `src`.

Dans un fichier `requirements.txt` ajoutez la ligne

```txt
discord.py==2.3.2
```

Le contenu de votre repertoire projet `discord-bot` doit ressembler à

```bash
.
├── .env
├── requirements.txt
└── src
    └── main.py

2 directories, 3 files
```

### Le bot dans main.py


Dans le fichier main.py

une seule commande : `/hello`

[TODO] commenter et proposer des autres commandes

### A vous

Vous allez maintenant écrire les fichier suivants

- le `Dockerfile` qui permet de construire votre image et de runner le container
- le `compose.yaml` qui permet lancer le bot avec `docker compose up`
- le `.dockerignore` pour éviter que `.env` ne se retrouve dans le container

#### Le Dockerfile

Un Dockerfile classique

le plus simple est

- de partir de l'image `python:3.12-slim`
- le workdir est '/app'
- de copier le requirements.txt et d'installer les librairies avec `pip install`
- de copier le code `main.py`
- et de l'executer avec `python main.py` de préference avec une syntaxe **Exec** (définit la commande et ses arguments sous forme d'array)


#### Le compose.yaml


Pourquoi un docker compose.yaml alors qu'il n'y a qu'un service ?

* Gestion des variables d'environnement
  - Dans votre cas, Docker Compose fournit un moyen propre d'injecter la variable d'environnement `DISCORD_TOKEN`.
  - Vous pouvez utiliser un fichier `.env` avec Compose automatiquement, alors qu'avec Docker seul, vous devriez les spécifier en ligne de commande ou utiliser `--env-file`.

* Commandes standardisées
  - Au lieu de se souvenir des commandes Docker build/run avec tous leurs paramètres, vous pouvez utiliser :

 ```bash
 docker compose up --build    # Construire et démarrer
 docker compose down         # Arrêter et supprimer les conteneurs
 ```

* Scalabilité future
  - Si vous décidez plus tard d'ajouter d'autres services (comme une base de données ou un cache), vous n'aurez pas besoin de refactorer.
  - Il suffit d'ajouter de nouveaux services dans le même fichier compose.

* Développement local
  - Compose propose des commandes comme `docker compose logs` et `docker compose restart` qui sont plus pratiques que leurs équivalents Docker.
  - Cela facilite également le partage de la configuration du projet avec d'autres développeurs.

Donc ecrivez un compose.yaml avec

- un seul service appelé `discord-bot`
- construit à partir du Dockerfile (et qui ne part pas d'une image)
- avec les volumes adéquats
- et la variable d'environnement `DISCORD_TOKEN`


La commande suivante permet de vérifier que le fichier est bien écrit

```bash
docker compose -f compose.yaml config
```

Lorsque vous exécutez `docker compose -f compose.yaml config`, Docker Compose :

- Analyse le fichier et vérifie la syntaxe et la structure.
- Valide les services, volumes, réseaux, et configurations.
- Combine les configurations si plusieurs fichiers Compose sont utilisés.
- Affiche la configuration finale.

En cas d'erreur (syntaxe, champs manquants, configurations non prises en charge), la commande les signalera. En résumé, cette commande valide le fichier et affiche la configuration finale, en indiquant les éventuelles erreurs.

Et vous pouvez bien entendu lancer le bot avec

```bash
docker compose up
```

### Inviter le bot sur le server discord

Pour que le bot devienne actif, il faut l'autoriser  et l'inviter

1. Go back to the Discord Developer Portal
2. Go to the "OAuth2" tab, then "URL Generator"
3. Select "bot" under "Scopes"
4. Choose the permissions you want your bot to have
5. Copy the generated URL and open it in a browser
6. Select the server you want to add the bot to and authorize it

Your bot should now be running and connected to your Discord server!

[TODO] verifier que le student peut ajouter le bot au server!

1216407543622926357

https://discord.com/api/oauth2/authorize?client_id=BOT_CLIENT_ID&permissions=PERMISSIONS_NUMBER&scope=bot


### ajouter des fonctinonalités

A ce stade vous pouvez ajouter toutes les fonctionnalités que vous souhaitez


### Other services that could be useful for a more complex bot

Here's an enhanced `compose.yaml` with additional services commonly useful for Discord bots:

```yaml
version: '3'
services:
  discord-bot:
    build: .
    environment:
      - DISCORD_TOKEN=${DISCORD_TOKEN}
    depends_on:
      - redis
      - db

  # Cache for rate limiting, cooldowns, temporary data
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data

  # Database for persistent data (user preferences, server settings, etc)
  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_DB=discord_bot
      - POSTGRES_USER=bot_user
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  # Optional: Admin panel to manage bot data
  adminer:
    image: adminer
    ports:
      - "8080:8080"
    depends_on:
      - db

  # Optional: Monitoring
  prometheus:
    image: prom/prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    depends_on:
      - prometheus

volumes:
  redis-data:
  postgres-data:
```

Here's why each service could be useful:

1. Redis:
   - Managing command cooldowns
   - Caching API responses
   - Temporary data storage
   - Rate limiting implementation
   - Queue system for music bots

2. PostgreSQL:
   - Storing server configurations
   - User preferences and statistics
   - Economy system data
   - Persistent leaderboards
   - Custom commands storage

3. Adminer:
   - Web interface to manage database
   - Useful for debugging and data management
   - Easy way to view and modify bot data

4. Prometheus + Grafana:
   - Monitor bot performance
   - Track command usage
   - Monitor memory/CPU usage
   - Create dashboards for:
     - Active servers
     - Command popularity
     - Error rates
     - Response times

Additional services you might consider depending on your bot's features:

```yaml
  # For music bots
  lavalink:
    image: fredboat/lavalink:dev
    ports:
      - "2333:2333"

  # For image processing/AI features
  ai-service:
    build: ./ai-service
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}

  # For handling background tasks
  celery-worker:
    build: .
    command: celery -A tasks worker
    depends_on:
      - redis
      - discord-bot

  # Message queue for task distribution
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
```

### Multi stage builds

https://chatgpt.com/c/671a7937-6e50-800e-a00a-6680e74eecbe

https://claude.ai/chat/d57aecc0-d6db-4e12-96ba-a76174503025

On peut optimiser le docker file avec un build multi stage.

Le multi stage build consiste à supprimer les fichiers qui ont été crées lors des installs pour réduire la taille finale de l'image et du container.


Voici ce que ca donnerait pour notre Dockerfile

```yaml
```

Mais il est assez evident que dans notre cas assez simple, le gain de taille obtenu avec un build multi stage est assez limité.

## GitHub Actions Setup

1. Create a `.github/workflows/deploy.yml` file in your repository:

```yaml
name: Deploy Discord Bot

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Login to DockerHub
      uses: docker/login-action@v1
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v2
      with:
        context: .
        push: true
        tags: yourdockerhubusername/discord-bot:latest

    - name: Deploy to server
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SERVER_SSH_KEY }}
        script: |
          docker pull yourdockerhubusername/discord-bot:latest
          docker stop discord-bot || true
          docker rm discord-bot || true
          docker run -d --name discord-bot -e DISCORD_TOKEN=${{ secrets.DISCORD_TOKEN }} yourdockerhubusername/discord-bot:latest
```

2. Set up secrets in your GitHub repository:

- DOCKERHUB_USERNAME
- DOCKERHUB_TOKEN
- SERVER_HOST
- SERVER_USERNAME
- SERVER_SSH_KEY
- DISCORD_TOKEN

## validate, lint, test Dockerfile and compose.yaml

Yes! You can use GitHub Actions to validate and test both your Dockerfile and compose.yaml files. Here's a comprehensive GitHub Actions workflow:



```yaml
name: Docker Validation

on:
  push:
    paths:
      - 'Dockerfile'
      - 'docker-compose.yaml'
      - '.github/workflows/docker-validate.yml'
  pull_request:
    paths:
      - 'Dockerfile'
      - 'docker-compose.yaml'
      - '.github/workflows/docker-validate.yml'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate Docker Compose file
        uses: docker/compose-cli@v2
        with:
          command: config
          file: ./docker-compose.yaml

      - name: Install Hadolint
        run: |
          curl -Lo hadolint https://github.com/hadolint/hadolint/releases/download/v2.12.0/hadolint-Linux-x86_64
          chmod +x hadolint
          sudo mv hadolint /usr/local/bin/

      - name: Lint Dockerfile
        run: hadolint Dockerfile

      - name: Test Docker build
        run: docker build -t test-image .

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'config'
          scan-ref: '.'
          format: 'table'

      - name: Run Snyk to check Docker image for vulnerabilities
        uses: snyk/actions/docker@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: test-image
          args: --file=Dockerfile

  compose-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create env file
        run: |
          echo "DISCORD_TOKEN=dummy-token" > .env
          echo "DB_PASSWORD=dummy-password" >> .env

      - name: Test Compose Up
        run: |
          docker compose up -d
          sleep 10  # Wait for services to start
          docker compose ps --format json
          docker compose logs
          docker compose down

```

This workflow provides several layers of validation:

1. Docker Compose Validation:
   - Validates the syntax of your compose file
   - Ensures all referenced services and volumes are properly defined

2. Dockerfile Linting with Hadolint:
   - Checks for best practices
   - Identifies potential issues
   - Ensures consistency

3. Build Testing:
   - Verifies that the Dockerfile can build successfully

4. Security Scanning:
   - Uses Trivy to scan for configuration issues
   - Uses Snyk to check for vulnerabilities (requires SNYK_TOKEN)

5. Compose Integration Test:
   - Tests if all services can start together
   - Checks for proper container orchestration

To enhance this further, you could:

1. Add custom test scripts to verify service connectivity:
```yaml
      - name: Test Service Connectivity
        run: |
          docker compose exec discord-bot ping -c 1 redis
          docker compose exec discord-bot ping -c 1 db
```

2. Add specific linting for compose files:
```yaml
      - name: Install compose-linter
        run: npm install -g compose-linter

      - name: Lint compose file
        run: compose-linter docker-compose.yaml
```

3. Add container structure tests:
```yaml
      - name: Container Structure Test
        uses: plexsystems/container-structure-test-action@v1
        with:
          image: test-image
          config: container-structure-tests.yaml
```


### Then deploy to host





## Running Locally with Docker

To run your bot locally using Docker:

1. Build the Docker image:

```bash
docker build -t discord-bot .
```

1. Run the container:

```bash
docker run -e DISCORD_TOKEN=your_token_here discord-bot
```

Or use Docker Compose:

```bash
DISCORD_TOKEN=your_token_here docker-compose up
```

