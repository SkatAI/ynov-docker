# Dockerfile

Dans cette session nous allons voir les **Dockerfile**

- comment écrire une Dockerfile, comment l'utiliser
- les instructions de base
- lancer un server web nginx
- améliorer le Dockerfile avec HEALTHCHECK, MAINTAINER, Cleanup, Non-root User
- V2 en partant de nginx:latest (voir <https://training.play-with-docker.com/beginner-linux/>)

- difference entre CMD et ENTRYPOINT
- persistence des données avec VOLUME
- variables d'environnement et tokens secret (passwords, clef API etc)

puis

- notion de layers
- rapidité du build
- multistage build

Applications

- un Dockerfile pour une app streamlit simple
- un Docker file pour une app python avec scikit learn, LLM ?
- bot discord ?

## Pourquoi écrire une Dockerfile

Invoquer une image de base et de manuellement la modifier en ajoutant des éléments n'est pas un bon moyen de construire des images. Ca ne scale pas et il y a trop de risques d'erreur.

It does not scale!

- aucun moyen de reproduire les étapes de construction
- pas de version control
- erreur humaine
- difficile de spécifier les versions
- faible reproductibilité

Heureusement docker peut construire des images automatiquement à partir d'un fichier d'instruction appelé Dockerfile.

Ce fichier contient une suite d'instructions, toutes au format **INSTRUCTION arguments**;

Par exemple, ce Dockerfile install python fait tourner un script

```bash
FROM ubuntu:latest
RUN apt-get install python
COPY hello-world.py
CMD python hello-world.py
```

Les instructions sont écrites dans un fichier intitulé par défaut Dockerfile

Puis on construit l'image avec

```bash
docker build .
```

ou si le nom du Dockerfile n'est pas ... Dockerfile

```bash
docker build -f nom_du_dockerfile
```

Ce qui permet par exemple d'avoir des dockerfile pour différents environnements : Dockerfile.dev, Dockerfile.test etc

On peut donc en quelques lignes recréer l'image de serveur web Nginx que nous avons construite manuellement.

Voici la Liste des instructions disponibles: <https://docs.docker.com/reference/dockerfile/>

| Instruction  | Description                                                |
|--------------|------------------------------------------------------------|
| ADD          | Add local or remote files and directories.                 |
| ARG          | Use build-time variables.                                  |
| CMD          | Specify default commands.                                  |
| COPY         | Copy files and directories.                                |
| ENTRYPOINT   | Specify default executable.                                |
| ENV          | Set environment variables.                                 |
| EXPOSE       | Describe which ports your application is listening on.     |
| FROM         | Create a new build stage from a base image.                |
| HEALTHCHECK  | Check a container's health on startup.                     |
| LABEL        | Add metadata to an image.                                  |
| MAINTAINER   | Specify the author of an image.                            |
| ONBUILD      | Specify instructions for when the image is used in a build.|
| RUN          | Execute build commands.                                    |
| SHELL        | Set the default shell of an image.                         |
| STOPSIGNAL   | Specify the system call signal for exiting a container.    |
| USER         | Set user and group ID.                                     |
| VOLUME       | Create volume mounts.                                      |
| WORKDIR      | Change working directory.                                  |

Nous allons partir d'un jeu d'instruction simple et construire des images de plus en plus complexes.

En parallèle de pouvoir specifier le contenu des images on regardera les différents paramètres disponibles pour la commande build notamment le mode de caching et la déclaration du réseau.

## Premier Dockerfile

### Nom des fichiers

Dns la suite nous allons ecrire plusieurs dockerfile. Donc nous utiliserons un nom de fichier unique et different de celui par defaut Dockerfile a chaque fois.

Le mieux est de créer un repertoire dédié au Dockerfiles
Mais normallement le Dockerfile est crée a la racine du project
On buildera les images a partir des dockerfiles avec la commande

```bash
docker build -f <nom du dockerfile> -t <nom de l'image>:<tag de l'image> <nom du repertoire du dockerfile>
```

### hello_world.docker

Commençons par un exemple tres simple

```Dockerfile
FROM alpine:latest
CMD echo Hello World!
```

Sauvegardez ces lignes dans un fichier `hello_world.docker`
puis

```bash
docker build -f  hello_world.docker -t ynov:hello-world .
```

cela build l'image `ynov:hello-world` à partir du fichier `hello_world.docker` situé dans le repertoire courant `.`.

On obtient:

![docker build -f  hello_world.docker](./../../img/docker-build-helloworld.png)

et maintenant on peut lancer le container:

```bash
docker run ynov:hello-world
```

ce qui retourne

```bash
hello World!
```

## Les instructions

Les Principales :

- FROM
- WORKDIR
- ADD & COPY see p66
- RUN
- CMD & ENTRYPOINT p70

et aussi:

- ENV
- VOLUME
- LABEL
- EXPOSE

### Premier exemple

On va écrire le Dockerfile qui fais tourner un webserver NGinx et qui donne une page web index.html à l'adresse localhost:8080

Sur votre machine, créez un nouveau repertoire

```bash
mkdir -p ./demo-nginx
cd ./demo-nginx
```

Créez le fichier  `nginx.local.conf` et y copier le contenu suivant:

```conf
daemon off;

events {
 worker_connections 1024;
}

http {
 server {
    listen 80;
    root /var/www/html;
    index index.html;
 }
}
```

Télechargez une page web html comme par exemple <https://fr.wikipedia.org/wiki/Linux> et renommez le fichier en index.html
`mv Linux index.html`

On travaille sur Ubuntu donc avec `apt-get` comme package manager

Les instructions à écrire dans le fichier Dockerfile sont

- A partir de Ubuntu
- installer nginx et wget
- Exposer le port 80
- creer un workdir  /var/www/html
- et cd /var/www/html
- copier le fichier index.html dans /var/www/html/
- copier nginx.local.conf dans /etc/nginx/nginx.conf
- run nginx

see <https://claude.ai/chat/10486c0b-bd3a-4daf-ba7d-9c5fde902eb0>

- from Ubuntu
- install nginx et wget
- Expose  port 80
- create a  workdir  /var/www/html
- cd /var/www/html
- copy local file index.html in /var/www/html/
- copy nginx.local.conf in /etc/nginx/nginx.conf
- run nginx

Les instructions a utiliser sont
FROM
RUN
WORKDIR
COPY

solution

```bash
FROM ubuntu:latest

# Install nginx and wget
RUN apt-get update && apt-get install -y nginx wget

# Expose port 80
EXPOSE 80

# Set working directory
WORKDIR /var/www/html

# Copy local index.html to the container
COPY index.html /var/www/html/

# Copy nginx configuration
COPY nginx.local.conf /etc/nginx/nginx.conf

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
```

Une fois le fichier écrit et sauvegardé,

- creez l'image
  - taggez avec `-t` et le nom `nginx-demo:01`
- creez et lancez le container
  - mode detaché `-d`
  - mappez le port interne du container `80` au port externe `8080`
- verifiez que la page apparait bien sur localhost:8080

```bash
docker build -t nginx-demo:01 .
docker run -d -p 8080:80 nginx-demo:01
```

Vérifiez que le container tourne avec `docker ps -a`

```bash
CONTAINER ID   IMAGE                    COMMAND                  CREATED
9cef311acfd2   nginx-demo:01            "nginx -g 'daemon of…"   9 seconds ago

STATUS                      PORTS     NAMES
Exited (1) 8 seconds ago              cool_moore
```

Maintenant allez dans le container (`docker exec -it nginx-demo:01 /bin/bash`)

- verifiez que le process nginx tourne bien (ps aux | grep nginx)
- verifiez que ...

--------

!!! le container s'arrete otut de suite meme en - mode

## On va publier l'image sur docker hub

- creez un compte sur docker hub
-

## Guidelines and Recommendations for Writing Dockerfiles p79

keep the build context as minimal
• Use multi-stage builds
• Skip unwanted packages
Minimize the number of layers

## CMD vs Entrypoint

excellent exemple

<https://medium.com/@mrdevsecops/dockerfile-cmd-vs-entrypoint-78b219d55df0>

Docker ENTRYPOINT and CMD can have two forms:

    Shell form
    Exec form

The syntax for any command in shell form is:

<instruction> <command>

The syntax for instructions in exec form is:

<instruction> ["executable", "parameter"]

You can write Docker CMD/ENTRYPOINT instructions in both forms:

- CMD echo "Hello World" (shell form)
- CMD ["echo", "Hello World"] (exec form)
- ENTRYPOINT echo "Hello World" (shell form)
- ENTRYPOINT ["echo", "Hello World"] (exec form)

### Multi-Stage Builds (see file)

what is the advantage of multi-stage builds over docker compose
see <https://claude.ai/chat/dfdf46cb-7a51-4f3f-9650-2de92e4ec424>

## Exercices

- BUILDING A SIMPLE HELLO WORLD DOCKER IMAGE p81

## Exaemple avec Nginx

<https://medium.com/@mrdevsecops/dockerfile-nginx-842ba0a55b82>

## Avec python et flask

<https://medium.com/@mrdevsecops/dockerfile-python-flask-e03a3c0dfe65>

Exercice :
voici le app.py et le requirements.txt
creez le Dockerfile avec

- la base : python-slim ...
-

J'ai la target, aux etudiants d'ecrire le Dockerfile
et de le tester

## How To Dockerize an Angular Application with multistage build

<https://medium.com/@mrdevsecops/dockerfile-multiple-stage-build-3ee540e7b221>
